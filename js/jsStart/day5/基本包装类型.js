// 基本包装类型
// 为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。
// 这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。
// 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，
// 从而让我们能够调用一些方法来操作这些数据。
var s1 = "some text"; 
var s2 = s1.substring(2);
console.log(s2) //me text
// 这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理

// 创建 String 类型的一个实例；
// 在实例上调用指定的方法；
// 销毁这个实例；
// 可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。
// (1)把简单数据类型包装为复杂数据类型
// var s1 = new String("some text"); 
// (2) 把临时变量的值 给s2
// var s2 = s1.substring(2);
// (3)销毁这个临时变量 
// s1 = null;




// 引用类型与基本包装类型的主要区别就是对象的生存期
// 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。
// 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。
// 这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子：

var s1 = "some text"; 
s1.color = "red"; 
console.log(s1.color); //undefined

// 在此，第二行代码试图为字符串 s1 添加一个 color 属性。
// 但是，当第三行代码再次访问 s1 时，其 color 属性不见了。
// 问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了
// 。第三行代码又创建自己的 String 对象，而该对象没有 color 属性